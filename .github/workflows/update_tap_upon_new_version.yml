name: Auto Sign and Update SourceGit

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      version:
        description: 'SourceGit version (e.g., v8.40) - leave empty for latest'
        required: false
      force_update:
        description: 'Force update even if version is the same'
        required: false
        type: boolean
        default: false
  
  # Check 4x daily (same as your old workflow)
  schedule:
    - cron: '0 0,6,12,18 * * *'

jobs:
  check-and-sign:
    runs-on: macos-latest
    
    steps:
      - name: Checkout tap repo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
      
      # ============================================
      # VERSION DETECTION (from old workflow)
      # ============================================
      - name: Fetch latest release version
        id: fetch_version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ -n "${{ github.event.inputs.version }}" ]; then
            # Manual trigger with specific version
            VERSION="${{ github.event.inputs.version }}"
            VERSION_NUM="${VERSION#v}"
          else
            # Auto-detect latest version (scheduled run)
            latest_version=$(curl -sL -H "Authorization: token $GITHUB_TOKEN" \
              https://api.github.com/repos/sourcegit-scm/sourcegit/releases/latest | \
              jq -r ".tag_name")
            
            if [ -z "$latest_version" ] || [ "$latest_version" == "null" ]; then
              echo "âŒ Failed to fetch latest version from GitHub API."
              exit 1
            fi
            
            VERSION="$latest_version"
            VERSION_NUM="${latest_version#v}"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "version_num=$VERSION_NUM" >> $GITHUB_OUTPUT
          echo "âœ… Target version: $VERSION ($VERSION_NUM)"
      
      - name: Get current version from sourcegit.rb
        id: current_version
        run: |
          if [ -f "./Casks/sourcegit.rb" ]; then
            current_version=$(grep 'version ' ./Casks/sourcegit.rb | cut -d '"' -f 2)
            echo "current_version=$current_version" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Current version in cask: $current_version"
          else
            echo "current_version=" >> $GITHUB_OUTPUT
            echo "âš ï¸  No existing cask file found"
          fi
      
      - name: Compare versions
        id: version_check
        run: |
          LATEST="${{ steps.fetch_version.outputs.version_num }}"
          CURRENT="${{ steps.current_version.outputs.current_version }}"
          FORCE="${{ github.event.inputs.force_update }}"
          
          if [ "$FORCE" == "true" ]; then
            echo "ðŸ”¨ Force update enabled. Proceeding regardless of version."
            echo "should_update=true" >> $GITHUB_OUTPUT
          elif [ "$LATEST" != "$CURRENT" ]; then
            echo "âœ… Versions differ ($CURRENT â†’ $LATEST). Proceeding with signing."
            echo "should_update=true" >> $GITHUB_OUTPUT
          else
            echo "âœ¨ Versions are the same ($CURRENT). No action needed."
            echo "ðŸ’¡ Use 'Force update' checkbox to update anyway."
            echo "should_update=false" >> $GITHUB_OUTPUT
          fi
      
      # ============================================
      # CHECK IF ALREADY SIGNED
      # ============================================
      - name: Check if already signed
        id: check_signed
        if: steps.version_check.outputs.should_update == 'true'
        run: |
          VERSION="${{ steps.fetch_version.outputs.version }}"
          FORCE="${{ github.event.inputs.force_update }}"
          
          if [ "$FORCE" == "true" ]; then
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ðŸ”¨ Force update: Will re-sign even if release exists"
          elif gh release view "${VERSION}-signed" &>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Version ${VERSION} already signed"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ðŸ”¨ Version ${VERSION} needs signing"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      # ============================================
      # DELETE OLD RELEASE IF FORCE UPDATE
      # ============================================
      - name: Delete old signed release (force update)
        if: steps.version_check.outputs.should_update == 'true' && github.event.inputs.force_update == 'true'
        run: |
          VERSION="${{ steps.fetch_version.outputs.version }}"
          
          if gh release view "${VERSION}-signed" &>/dev/null; then
            echo "ðŸ—‘ï¸  Deleting existing signed release..."
            gh release delete "${VERSION}-signed" --yes --cleanup-tag
            echo "âœ… Old release deleted"
          else
            echo "â„¹ï¸  No existing release to delete"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      # ============================================
      # DOWNLOAD AND SIGN (new workflow)
      # ============================================
      - name: Download SourceGit
        if: steps.version_check.outputs.should_update == 'true' && steps.check_signed.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.fetch_version.outputs.version }}"
          VERSION_NUM="${{ steps.fetch_version.outputs.version_num }}"

          echo "ðŸ“¥ Downloading SourceGit ${VERSION} for both architectures..."

          # Download ARM64 version
          echo "ðŸ“¥ Downloading ARM64 version..."
          curl -L -o sourcegit-arm64.zip \
            "https://github.com/sourcegit-scm/sourcegit/releases/download/${VERSION}/sourcegit_${VERSION_NUM}.osx-arm64.zip"

          # Download x64 version
          echo "ðŸ“¥ Downloading x64 version..."
          curl -L -o sourcegit-x64.zip \
            "https://github.com/sourcegit-scm/sourcegit/releases/download/${VERSION}/sourcegit_${VERSION_NUM}.osx-x64.zip"

          # Extract ARM64
          echo "ðŸ“¦ Extracting ARM64..."
          mkdir -p arm64
          unzip -q sourcegit-arm64.zip -d arm64

          # Extract x64
          echo "ðŸ“¦ Extracting x64..."
          mkdir -p x64
          unzip -q sourcegit-x64.zip -d x64

          ls -la arm64/
          ls -la x64/

          if [ ! -d "arm64/SourceGit.app" ]; then
            echo "âŒ ARM64 SourceGit.app not found after extraction"
            exit 1
          fi

          if [ ! -d "x64/SourceGit.app" ]; then
            echo "âŒ x64 SourceGit.app not found after extraction"
            exit 1
          fi

          echo "âœ… Both ARM64 and x64 apps extracted and ready for signing"
      
      - name: Import signing certificate
        if: steps.version_check.outputs.should_update == 'true' && steps.check_signed.outputs.exists == 'false'
        env:
          CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          echo "ðŸ” Setting up keychain..."
          
          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain
          
          # Decode and import certificate
          echo "$CERTIFICATE_BASE64" | base64 --decode > certificate.p12
          security import certificate.p12 \
            -k build.keychain \
            -P "$CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/productsign
          
          # Allow codesign access
          security set-key-partition-list -S apple-tool:,apple: \
            -s -k "$KEYCHAIN_PASSWORD" build.keychain
          
          # List identities to verify
          echo "âœ… Available identities:"
          security find-identity -v
      
      - name: Sign application
        if: steps.version_check.outputs.should_update == 'true' && steps.check_signed.outputs.exists == 'false'
        env:
          APPLE_IDENTITY: ${{ secrets.APPLE_IDENTITY }}
        run: |
          echo "âœï¸  Signing SourceGit apps for both architectures..."

          # Create entitlements file
          cat > entitlements.plist << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>com.apple.security.cs.allow-jit</key>
              <true/>
              <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
              <true/>
              <key>com.apple.security.cs.disable-library-validation</key>
              <true/>
          </dict>
          </plist>
          EOF

          # Sign both architectures
          for ARCH in arm64 x64; do
            echo "âœï¸  Signing ${ARCH} app..."
            APP_PATH="${ARCH}/SourceGit.app"

            # Sign all frameworks and dylibs first
            find ${APP_PATH}/Contents -type f \( -name "*.dylib" -o -name "*.framework" \) -exec \
              codesign --force --sign "$APPLE_IDENTITY" \
              --options runtime \
              --timestamp {} \; 2>/dev/null || true

            # Sign all executables
            find ${APP_PATH}/Contents/MacOS -type f -perm +111 -exec \
              codesign --force --sign "$APPLE_IDENTITY" \
              --options runtime \
              --entitlements entitlements.plist \
              --timestamp {} \;

            # Sign the app bundle itself
            codesign --force --sign "$APPLE_IDENTITY" \
              --options runtime \
              --entitlements entitlements.plist \
              --timestamp \
              --deep \
              ${APP_PATH}

            # Verify signature
            echo "âœ… Verifying ${ARCH} signature..."
            codesign --verify --deep --strict --verbose=2 ${APP_PATH}

            # Check signing status
            echo "ðŸ“ Checking ${ARCH} signing status (will show 'Unnotarized' - this is expected):"
            spctl --assess --type execute --verbose ${APP_PATH} || echo "âš ï¸  Not notarized yet (expected at this stage)"
          done

          echo "âœ… Both architectures signed! Moving to notarization..."
          
      - name: Create DMG
        if: steps.version_check.outputs.should_update == 'true' && steps.check_signed.outputs.exists == 'false'
        env:
          APPLE_IDENTITY: ${{ secrets.APPLE_IDENTITY }}
        run: |
          VERSION="${{ steps.fetch_version.outputs.version }}"

          echo "ðŸ“¦ Creating DMGs for both architectures..."

          # Create ARM64 DMG
          echo "ðŸ“¦ Creating ARM64 DMG..."
          hdiutil create -volname "SourceGit" \
            -srcfolder arm64/SourceGit.app \
            -ov -format UDZO \
            SourceGit-${VERSION}-arm64-signed.dmg

          # Sign the ARM64 DMG
          codesign --force --sign "$APPLE_IDENTITY" \
            --timestamp \
            SourceGit-${VERSION}-arm64-signed.dmg

          # Verify ARM64 DMG signature
          codesign --verify --verbose SourceGit-${VERSION}-arm64-signed.dmg

          # Create x64 DMG
          echo "ðŸ“¦ Creating x64 DMG..."
          hdiutil create -volname "SourceGit" \
            -srcfolder x64/SourceGit.app \
            -ov -format UDZO \
            SourceGit-${VERSION}-x64-signed.dmg

          # Sign the x64 DMG
          codesign --force --sign "$APPLE_IDENTITY" \
            --timestamp \
            SourceGit-${VERSION}-x64-signed.dmg

          # Verify x64 DMG signature
          codesign --verify --verbose SourceGit-${VERSION}-x64-signed.dmg

          echo "âœ… Both DMGs created and signed!"
      
      - name: Notarize application
        if: steps.version_check.outputs.should_update == 'true' && steps.check_signed.outputs.exists == 'false'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          VERSION="${{ steps.fetch_version.outputs.version }}"

          echo "ðŸŽ Submitting both DMGs for notarization..."

          # Notarize ARM64 DMG
          echo "ðŸŽ Submitting ARM64 DMG for notarization..."
          xcrun notarytool submit SourceGit-${VERSION}-arm64-signed.dmg \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait \
            --timeout 30m

          echo "ðŸ“Ž Stapling ARM64 notarization ticket..."
          xcrun stapler staple SourceGit-${VERSION}-arm64-signed.dmg

          echo "âœ… Verifying ARM64 notarization..."
          spctl --assess --type open --context context:primary-signature \
            -vv SourceGit-${VERSION}-arm64-signed.dmg

          # Notarize x64 DMG
          echo "ðŸŽ Submitting x64 DMG for notarization..."
          xcrun notarytool submit SourceGit-${VERSION}-x64-signed.dmg \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait \
            --timeout 30m

          echo "ðŸ“Ž Stapling x64 notarization ticket..."
          xcrun stapler staple SourceGit-${VERSION}-x64-signed.dmg

          echo "âœ… Verifying x64 notarization..."
          spctl --assess --type open --context context:primary-signature \
            -vv SourceGit-${VERSION}-x64-signed.dmg

          echo "âœ… Both DMGs notarized successfully!"
      
      - name: Calculate SHA256
        if: steps.version_check.outputs.should_update == 'true' && steps.check_signed.outputs.exists == 'false'
        id: sha256
        run: |
          VERSION="${{ steps.fetch_version.outputs.version }}"

          # Calculate SHA256 for ARM64 DMG
          SHA256_ARM64=$(shasum -a 256 SourceGit-${VERSION}-arm64-signed.dmg | cut -d' ' -f1)
          echo "sha256_arm64=$SHA256_ARM64" >> $GITHUB_OUTPUT
          echo "ðŸ“ ARM64 SHA256: $SHA256_ARM64"

          # Calculate SHA256 for x64 DMG
          SHA256_X64=$(shasum -a 256 SourceGit-${VERSION}-x64-signed.dmg | cut -d' ' -f1)
          echo "sha256_x64=$SHA256_X64" >> $GITHUB_OUTPUT
          echo "ðŸ“ x64 SHA256: $SHA256_X64"
      
      - name: Create GitHub Release
        if: steps.version_check.outputs.should_update == 'true' && steps.check_signed.outputs.exists == 'false'
        uses: softprops/action-gh-release@v1
        with:
          files: |
            SourceGit-${{ steps.fetch_version.outputs.version }}-arm64-signed.dmg
            SourceGit-${{ steps.fetch_version.outputs.version }}-x64-signed.dmg
          tag_name: ${{ steps.fetch_version.outputs.version }}-signed
          name: SourceGit ${{ steps.fetch_version.outputs.version }} (Signed & Notarized)
          body: |
            **Signed and notarized build of SourceGit ${{ steps.fetch_version.outputs.version }}**

            - âœ… Code signed with Developer ID
            - âœ… Notarized by Apple
            - âœ… No `--no-quarantine` flag needed
            - ðŸ“¦ Available for both Apple Silicon (ARM64) and Intel (x64) Macs

            Original release: https://github.com/sourcegit-scm/sourcegit/releases/tag/${{ steps.fetch_version.outputs.version }}

            **Checksums:**
            - ARM64: `${{ steps.sha256.outputs.sha256_arm64 }}`
            - x64: `${{ steps.sha256.outputs.sha256_x64 }}`
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      # ============================================
      # UPDATE CASK (from old workflow)
      # ============================================
      - name: Get SHA256 from existing release
        if: steps.version_check.outputs.should_update == 'true' && steps.check_signed.outputs.exists == 'true'
        id: existing_sha
        run: |
          VERSION="${{ steps.fetch_version.outputs.version }}"

          # Download ARM64 DMG to calculate SHA
          echo "ðŸ“¥ Downloading ARM64 DMG..."
          curl -L -o temp-arm64.dmg \
            "https://github.com/ybeapps/homebrew-sourcegit/releases/download/${VERSION}-signed/SourceGit-${VERSION}-arm64-signed.dmg"

          SHA256_ARM64=$(shasum -a 256 temp-arm64.dmg | cut -d' ' -f1)
          echo "sha256_arm64=$SHA256_ARM64" >> $GITHUB_OUTPUT
          echo "ðŸ“ Existing ARM64 SHA256: $SHA256_ARM64"
          rm temp-arm64.dmg

          # Download x64 DMG to calculate SHA
          echo "ðŸ“¥ Downloading x64 DMG..."
          curl -L -o temp-x64.dmg \
            "https://github.com/ybeapps/homebrew-sourcegit/releases/download/${VERSION}-signed/SourceGit-${VERSION}-x64-signed.dmg"

          SHA256_X64=$(shasum -a 256 temp-x64.dmg | cut -d' ' -f1)
          echo "sha256_x64=$SHA256_X64" >> $GITHUB_OUTPUT
          echo "ðŸ“ Existing x64 SHA256: $SHA256_X64"
          rm temp-x64.dmg
      
      - name: Update cask formula using brew bump-cask-pr
        if: steps.version_check.outputs.should_update == 'true'
        env:
          VERSION: ${{ steps.fetch_version.outputs.version_num }}
          HOMEBREW_GITHUB_API_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          echo "=== Adding tap ==="
          brew tap ybeapps/homebrew-sourcegit
          TAP_REPO=$(brew --repository ybeapps/homebrew-sourcegit)
          echo "ðŸ“‚ Tap repository: $TAP_REPO"
          
          echo "=== Updating cask with signed version ==="
          # First, update the cask file to point to our signed release
          SHA256_ARM64="${{ steps.sha256.outputs.sha256_arm64 || steps.existing_sha.outputs.sha256_arm64 }}"
          SHA256_X64="${{ steps.sha256.outputs.sha256_x64 || steps.existing_sha.outputs.sha256_x64 }}"
          VERSION_TAG="${{ steps.fetch_version.outputs.version }}"

          cat > "$TAP_REPO/Casks/sourcegit.rb" << EOF
          cask "sourcegit" do
            version "${VERSION}"

            on_arm do
              sha256 "${SHA256_ARM64}"
              url "https://github.com/ybeapps/homebrew-sourcegit/releases/download/v#{version}-signed/SourceGit-v#{version}-arm64-signed.dmg",
                  verified: "github.com/ybeapps/homebrew-sourcegit/"
            end

            on_intel do
              sha256 "${SHA256_X64}"
              url "https://github.com/ybeapps/homebrew-sourcegit/releases/download/v#{version}-signed/SourceGit-v#{version}-x64-signed.dmg",
                  verified: "github.com/ybeapps/homebrew-sourcegit/"
            end

            name "SourceGit"
            desc "Git GUI client"
            homepage "https://github.com/sourcegit-scm/sourcegit"

            livecheck do
              url :homepage
              strategy :github_latest
            end

            depends_on macos: ">= :big_sur"

            app "SourceGit.app"

            zap trash: [
              "~/Library/Application Support/SourceGit",
              "~/Library/Saved Application State/com.sourcegit.app.savedState",
            ]
          end
          EOF
          
          echo "âœ… Updated cask formula:"
          cat "$TAP_REPO/Casks/sourcegit.rb"
          
          # Commit the changes in tap repo
          cd "$TAP_REPO"
          echo "=== Committing in tap repo ==="
          git add Casks/sourcegit.rb
          
          if git diff --cached --quiet; then
            echo "âš ï¸  No changes to commit"
          else
            git config user.name "GitHub Actions Bot"
            git config user.email "actions@github.com"
            git commit -m "Update SourceGit to version $VERSION (signed & notarized)"
            echo "âœ… Committed changes"
          fi
          
          echo "=== Commit Debug ==="
          echo "Git status after bump:"
          git status
          echo "Last 5 commits:"
          git log --oneline -5
          
          cd - # Go back to original directory
          
          # Fetch and merge changes
          git remote add local-other "$TAP_REPO"
          git fetch local-other
          git reset --hard local-other/main
          
          echo "=== Final push ==="
          git status
          git push origin
          git push origin main
          
          echo "âœ… Successfully updated homebrew tap!"

      # ============================================
      # UPDATE OFFICIAL HOMEBREW CASK
      # ============================================
      - name: Update official Homebrew cask
        if: steps.version_check.outputs.should_update == 'true'
        env:
          VERSION: ${{ steps.fetch_version.outputs.version_num }}
          HOMEBREW_GITHUB_API_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          echo "ðŸº Updating official Homebrew cask..."

          # Check if the cask exists in official Homebrew yet
          if brew info --cask sourcegit &>/dev/null; then
            echo "âœ… SourceGit cask found in official Homebrew"
            echo "ðŸ”„ Creating pull request to update to version $VERSION..."

            # Use brew bump-cask-pr to automatically create a PR
            brew bump-cask-pr --version="$VERSION" sourcegit || {
              echo "âš ï¸  Failed to create Homebrew PR. This might be because:"
              echo "   - A PR already exists for this version"
              echo "   - The version is already up to date"
              echo "   - GitHub rate limits"
              echo "Continuing anyway..."
            }
          else
            echo "â„¹ï¸  SourceGit not yet in official Homebrew"
            echo "   Once PR #242242 is merged, this step will auto-update the official cask"
          fi

      - name: Cleanup
        if: always()
        run: |
          security delete-keychain build.keychain 2>/dev/null || true
          rm -f certificate.p12 entitlements.plist
          echo "ðŸ§¹ Cleanup complete"
      
      - name: Summary
        if: steps.version_check.outputs.should_update == 'true'
        run: |
          VERSION="${{ steps.fetch_version.outputs.version }}"
          echo "### âœ… Workflow Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** Signed, notarized, and published" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Actions Taken:**" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Downloaded and signed both ARM64 and x64 builds" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Notarized with Apple" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Published to GitHub releases" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Updated tap repository" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”„ Attempted to update official Homebrew cask" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Installation:**" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "# Via this tap:" >> $GITHUB_STEP_SUMMARY
          echo "brew install --cask ybeapps/sourcegit/sourcegit" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Via official Homebrew (once PR is merged):" >> $GITHUB_STEP_SUMMARY
          echo "brew install --cask sourcegit" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
