name: Auto Sign and Update SourceGit

on:
  # Manual trigger
  workflow_dispatch:
    inputs:
      version:
        description: 'SourceGit version (e.g., v8.40) - leave empty for latest'
        required: false
  
  # Check 4x daily (same as your old workflow)
  schedule:
    - cron: '0 0,6,12,18 * * *'

jobs:
  check-and-sign:
    runs-on: macos-latest
    
    steps:
      - name: Checkout tap repo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
      
      # ============================================
      # VERSION DETECTION (from old workflow)
      # ============================================
      - name: Fetch latest release version
        id: fetch_version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          if [ -n "${{ github.event.inputs.version }}" ]; then
            # Manual trigger with specific version
            VERSION="${{ github.event.inputs.version }}"
            VERSION_NUM="${VERSION#v}"
          else
            # Auto-detect latest version (scheduled run)
            latest_version=$(curl -sL -H "Authorization: token $GITHUB_TOKEN" \
              https://api.github.com/repos/sourcegit-scm/sourcegit/releases/latest | \
              jq -r ".tag_name")
            
            if [ -z "$latest_version" ] || [ "$latest_version" == "null" ]; then
              echo "âŒ Failed to fetch latest version from GitHub API."
              exit 1
            fi
            
            VERSION="$latest_version"
            VERSION_NUM="${latest_version#v}"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "version_num=$VERSION_NUM" >> $GITHUB_OUTPUT
          echo "âœ… Target version: $VERSION ($VERSION_NUM)"
      
      - name: Get current version from sourcegit.rb
        id: current_version
        run: |
          if [ -f "./Casks/sourcegit.rb" ]; then
            current_version=$(grep 'version ' ./Casks/sourcegit.rb | cut -d '"' -f 2)
            echo "current_version=$current_version" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Current version in cask: $current_version"
          else
            echo "current_version=" >> $GITHUB_OUTPUT
            echo "âš ï¸  No existing cask file found"
          fi
      
      - name: Compare versions
        id: version_check
        run: |
          LATEST="${{ steps.fetch_version.outputs.version_num }}"
          CURRENT="${{ steps.current_version.outputs.current_version }}"
          
          if [ "$LATEST" != "$CURRENT" ]; then
            echo "âœ… Versions differ ($CURRENT â†’ $LATEST). Proceeding with signing."
            echo "should_update=true" >> $GITHUB_OUTPUT
          else
            echo "âœ¨ Versions are the same ($CURRENT). No action needed."
            echo "should_update=false" >> $GITHUB_OUTPUT
          fi
      
      # ============================================
      # CHECK IF ALREADY SIGNED
      # ============================================
      - name: Check if already signed
        id: check_signed
        if: steps.version_check.outputs.should_update == 'true'
        run: |
          VERSION="${{ steps.fetch_version.outputs.version }}"
          
          if gh release view "${VERSION}-signed" &>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Version ${VERSION} already signed"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ðŸ”¨ Version ${VERSION} needs signing"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      # ============================================
      # DOWNLOAD AND SIGN (new workflow)
      # ============================================
      - name: Download SourceGit
        if: steps.version_check.outputs.should_update == 'true' && steps.check_signed.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.fetch_version.outputs.version }}"
          VERSION_NUM="${{ steps.fetch_version.outputs.version_num }}"
          
          echo "ðŸ“¥ Downloading SourceGit ${VERSION}..."
          curl -L -o sourcegit.tar.gz \
            "https://github.com/sourcegit-scm/sourcegit/releases/download/${VERSION}/sourcegit_${VERSION_NUM}_osx-x64.tar.gz"
          
          tar -xzf sourcegit.tar.gz
          ls -la
      
      - name: Import signing certificate
        if: steps.version_check.outputs.should_update == 'true' && steps.check_signed.outputs.exists == 'false'
        env:
          CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          echo "ðŸ” Setting up keychain..."
          
          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain
          
          # Decode and import certificate
          echo "$CERTIFICATE_BASE64" | base64 --decode > certificate.p12
          security import certificate.p12 \
            -k build.keychain \
            -P "$CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/productsign
          
          # Allow codesign access
          security set-key-partition-list -S apple-tool:,apple: \
            -s -k "$KEYCHAIN_PASSWORD" build.keychain
          
          # List identities to verify
          echo "âœ… Available identities:"
          security find-identity -v
      
      - name: Sign application
        if: steps.version_check.outputs.should_update == 'true' && steps.check_signed.outputs.exists == 'false'
        env:
          APPLE_IDENTITY: ${{ secrets.APPLE_IDENTITY }}
        run: |
          echo "âœï¸  Signing SourceGit.app..."
          
          # Create entitlements file
          cat > entitlements.plist << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>com.apple.security.cs.allow-jit</key>
              <true/>
              <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
              <true/>
              <key>com.apple.security.cs.disable-library-validation</key>
              <true/>
          </dict>
          </plist>
          EOF
          
          # Sign all frameworks and dylibs first
          find SourceGit.app/Contents -type f \( -name "*.dylib" -o -name "*.framework" \) -exec \
            codesign --force --sign "$APPLE_IDENTITY" \
            --options runtime \
            --timestamp {} \; 2>/dev/null || true
          
          # Sign all executables
          find SourceGit.app/Contents/MacOS -type f -perm +111 -exec \
            codesign --force --sign "$APPLE_IDENTITY" \
            --options runtime \
            --entitlements entitlements.plist \
            --timestamp {} \;
          
          # Sign the app bundle itself
          codesign --force --sign "$APPLE_IDENTITY" \
            --options runtime \
            --entitlements entitlements.plist \
            --timestamp \
            --deep \
            SourceGit.app
          
          # Verify signature
          echo "âœ… Verifying signature..."
          codesign --verify --deep --strict --verbose=2 SourceGit.app
          spctl --assess --type execute --verbose SourceGit.app
      
      - name: Create DMG
        if: steps.version_check.outputs.should_update == 'true' && steps.check_signed.outputs.exists == 'false'
        env:
          APPLE_IDENTITY: ${{ secrets.APPLE_IDENTITY }}
        run: |
          VERSION="${{ steps.fetch_version.outputs.version }}"
          
          echo "ðŸ“¦ Creating DMG..."
          hdiutil create -volname "SourceGit" \
            -srcfolder SourceGit.app \
            -ov -format UDZO \
            SourceGit-${VERSION}-signed.dmg
          
          # Sign the DMG
          codesign --force --sign "$APPLE_IDENTITY" \
            --timestamp \
            SourceGit-${VERSION}-signed.dmg
          
          # Verify DMG signature
          codesign --verify --verbose SourceGit-${VERSION}-signed.dmg
      
      - name: Notarize application
        if: steps.version_check.outputs.should_update == 'true' && steps.check_signed.outputs.exists == 'false'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          VERSION="${{ steps.fetch_version.outputs.version }}"
          
          echo "ðŸŽ Submitting for notarization..."
          xcrun notarytool submit SourceGit-${VERSION}-signed.dmg \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait \
            --timeout 30m
          
          echo "ðŸ“Ž Stapling notarization ticket..."
          xcrun stapler staple SourceGit-${VERSION}-signed.dmg
          
          echo "âœ… Verifying notarization..."
          spctl --assess --type open --context context:primary-signature \
            -vv SourceGit-${VERSION}-signed.dmg
          
          echo "âœ… Notarization complete!"
      
      - name: Calculate SHA256
        if: steps.version_check.outputs.should_update == 'true' && steps.check_signed.outputs.exists == 'false'
        id: sha256
        run: |
          VERSION="${{ steps.fetch_version.outputs.version }}"
          SHA256=$(shasum -a 256 SourceGit-${VERSION}-signed.dmg | cut -d' ' -f1)
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "ðŸ“ SHA256: $SHA256"
      
      - name: Create GitHub Release
        if: steps.version_check.outputs.should_update == 'true' && steps.check_signed.outputs.exists == 'false'
        uses: softprops/action-gh-release@v1
        with:
          files: SourceGit-${{ steps.fetch_version.outputs.version }}-signed.dmg
          tag_name: ${{ steps.fetch_version.outputs.version }}-signed
          name: SourceGit ${{ steps.fetch_version.outputs.version }} (Signed & Notarized)
          body: |
            **Signed and notarized build of SourceGit ${{ steps.fetch_version.outputs.version }}**
            
            - âœ… Code signed with Developer ID
            - âœ… Notarized by Apple
            - âœ… No `--no-quarantine` flag needed
            
            Original release: https://github.com/sourcegit-scm/sourcegit/releases/tag/${{ steps.fetch_version.outputs.version }}
            
            SHA256: `${{ steps.sha256.outputs.sha256 }}`
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      # ============================================
      # UPDATE CASK (from old workflow)
      # ============================================
      - name: Get SHA256 from existing release
        if: steps.version_check.outputs.should_update == 'true' && steps.check_signed.outputs.exists == 'true'
        id: existing_sha
        run: |
          VERSION="${{ steps.fetch_version.outputs.version }}"
          
          # Download the DMG to calculate SHA
          curl -L -o temp.dmg \
            "https://github.com/ybeapps/homebrew-sourcegit/releases/download/${VERSION}-signed/SourceGit-${VERSION}-signed.dmg"
          
          SHA256=$(shasum -a 256 temp.dmg | cut -d' ' -f1)
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "ðŸ“ Existing SHA256: $SHA256"
          rm temp.dmg
      
      - name: Update cask formula using brew bump-cask-pr
        if: steps.version_check.outputs.should_update == 'true'
        env:
          VERSION: ${{ steps.fetch_version.outputs.version_num }}
          HOMEBREW_GITHUB_API_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          echo "=== Adding tap ==="
          brew tap ybeapps/homebrew-sourcegit
          TAP_REPO=$(brew --repository ybeapps/homebrew-sourcegit)
          echo "ðŸ“‚ Tap repository: $TAP_REPO"
          
          echo "=== Updating cask with signed version ==="
          # First, update the cask file to point to our signed release
          SHA256="${{ steps.sha256.outputs.sha256 || steps.existing_sha.outputs.sha256 }}"
          VERSION_TAG="${{ steps.fetch_version.outputs.version }}"
          
          cat > "$TAP_REPO/Casks/sourcegit.rb" << EOF
          cask "sourcegit" do
            version "${VERSION}"
            sha256 "${SHA256}"
            
            url "https://github.com/ybeapps/homebrew-sourcegit/releases/download/${VERSION_TAG}-signed/SourceGit-${VERSION_TAG}-signed.dmg"
            name "SourceGit"
            desc "Git GUI client"
            homepage "https://github.com/sourcegit-scm/sourcegit"
            
            # Signed and notarized - no --no-quarantine needed!
            app "SourceGit.app"
            
            zap trash: [
              "~/Library/Application Support/SourceGit",
              "~/Library/Saved Application State/com.sourcegit.app.savedState",
            ]
          end
          EOF
          
          echo "âœ… Updated cask formula:"
          cat "$TAP_REPO/Casks/sourcegit.rb"
          
          # Commit the changes in tap repo
          cd "$TAP_REPO"
          echo "=== Committing in tap repo ==="
          git add Casks/sourcegit.rb
          
          if git diff --cached --quiet; then
            echo "âš ï¸  No changes to commit"
          else
            git config user.name "GitHub Actions Bot"
            git config user.email "actions@github.com"
            git commit -m "Update SourceGit to version $VERSION (signed & notarized)"
            echo "âœ… Committed changes"
          fi
          
          echo "=== Commit Debug ==="
          echo "Git status after bump:"
          git status
          echo "Last 5 commits:"
          git log --oneline -5
          
          cd - # Go back to original directory
          
          # Fetch and merge changes
          git remote add local-other "$TAP_REPO"
          git fetch local-other
          git reset --hard local-other/main
          
          echo "=== Final push ==="
          git push origin main
          
          echo "âœ… Successfully updated homebrew tap!"
      
      - name: Cleanup
        if: always()
        run: |
          security delete-keychain build.keychain 2>/dev/null || true
          rm -f certificate.p12 entitlements.plist
          echo "ðŸ§¹ Cleanup complete"
      
      - name: Summary
        if: steps.version_check.outputs.should_update == 'true'
        run: |
          VERSION="${{ steps.fetch_version.outputs.version }}"
          echo "### âœ… Workflow Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** $VERSION" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** Signed, notarized, and published" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Users can now install with:" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "brew install --cask ybeapps/sourcegit/sourcegit" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
